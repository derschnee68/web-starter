import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
import { DocumentNode } from 'graphql';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format. */
  DateTime: any;
};

/** The Archipel workload objects */
export type ArchipelWorkload = {
  __typename?: 'ArchipelWorkload';
  /** The access keys ids associated to the workload */
  access_keys: Array<Scalars['String']>;
  /** The timestamp when the build is ended */
  build_end_at: Scalars['Int'];
  /** The timestamp when the build is started */
  build_start_at: Scalars['Int'];
  /** The status of the build */
  build_status: BuildStatus;
  /** If the workload must use the CPU or GPU */
  cpu: Scalars['Boolean'];
  /** ?? Same as CPU ? */
  device: Scalars['String'];
  /** The arguments used to build the docker image */
  docker_build_args: Scalars['String'];
  /** The location of the dockerfile on the registry */
  dockerfile: Scalars['String'];
  /** The timestamp when workload has been ended */
  end_at: Scalars['Int'];
  /** The workloads endpoint */
  endpoint?: Maybe<Scalars['String']>;
  /** The possible error message after the build */
  error_message: Scalars['String'];
  /** The workload id generated by Archipel */
  id: Scalars['ID'];
  /** The maximum number of batches needed by the workload */
  max_batch_size: Scalars['Int'];
  /** The maximum number of milliseconds for the workload to wait if the batch size is not full */
  max_waiting_ms: Scalars['Int'];
  /** The memory footprint of the workload */
  memory_footprint?: Maybe<WorkloadMemoryFootprint>;
  /** The arguments to run the script */
  script_args: Scalars['String'];
  /** The location of the script on the registry */
  script_path: Scalars['String'];
  /** The timestamp when workload has been started */
  start_at: Scalars['Int'];
  /** The workload status */
  status: WorkloadStatus;
  /** The registry url */
  url: Scalars['String'];
};

/** The influx time series data */
export type BillingUsageItem = {
  __typename?: 'BillingUsageItem';
  /** The start of time series */
  _start: Scalars['String'];
  /** The end of time series */
  _stop: Scalars['String'];
  /** The current time associated to value */
  _time: Scalars['String'];
  /** The minutes of usage */
  _value: Scalars['Float'];
  /** The associated runId */
  runId?: Maybe<Scalars['String']>;
  /** The type of compute, either cpu or gpu */
  status: Scalars['String'];
  /** The associated workloadId */
  workloadId?: Maybe<Scalars['String']>;
};

export enum BuildStatus {
  BENCHMARK = 'BENCHMARK',
  BUILDING = 'BUILDING',
  ERROR = 'ERROR',
  FAIL = 'FAIL',
  READY = 'READY',
  REGISTRATION = 'REGISTRATION',
  STARTING = 'STARTING',
  UNIT_TEST = 'UNIT_TEST',
  VERIFICATION = 'VERIFICATION',
}

/** Invoice data with detailed consumption data */
export type DetailedInvoice = {
  __typename?: 'DetailedInvoice';
  /** Invoice currency */
  currency: Scalars['String'];
  data: Array<InvoiceLine>;
  /** End date of the billing period */
  endAt: Scalars['Float'];
  /** Start date of the billing period */
  startAt: Scalars['Float'];
  /** Total due */
  total: Scalars['Float'];
};

/** Directory in the UNIX format */
export type Directory = {
  __typename?: 'Directory';
  /** The directory id, in the format `/[...path]/[directory]`. */
  id: Scalars['ID'];
  /** The directory name. */
  name: Scalars['String'];
};

/** An experiment based on a model template */
export type Experiment = {
  __typename?: 'Experiment';
  archived: Scalars['Boolean'];
  /** Return the content of the mounted artifact directory at given path */
  artifacts: FileSystem;
  /** If the experiment uses a code archive instead of a repository. Overrides the repository field to null. */
  code: Scalars['Boolean'];
  /** The date when the experiment has been created */
  createdAt: Scalars['DateTime'];
  /** The date when the experiment has finished */
  endedAt?: Maybe<Scalars['DateTime']>;
  /** The experiment ID */
  id: Scalars['ID'];
  /** The experiment mount points */
  mounts: Mounts;
  /** The experiment name */
  name: Scalars['String'];
  /** The repository where to fetch the code */
  repository?: Maybe<Repository>;
  /** The allocated hardware resources */
  resourcesAllocation?: Maybe<ResourcesAllocation>;
  /** The requested hardware resources */
  resourcesRequest: ResourcesRequest;
  /** The runtime container and its parameters */
  runtime: Runtime;
  /** The scripts to run during the execution lifecycle */
  scripts: Scripts;
  /** The date when the experiment has started to run */
  startedAt?: Maybe<Scalars['DateTime']>;
  /** The status of the corresponding SLURM job */
  status: ExperimentStatus;
  /** The date when the experiment has been sent to a runtime environment */
  submittedAt?: Maybe<Scalars['DateTime']>;
};

/** An experiment based on a model template */
export type ExperimentArtifactsArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** The experiment status */
export enum ExperimentStatus {
  BOOTING = 'BOOTING',
  CANCELED = 'CANCELED',
  COMPLETED = 'COMPLETED',
  ERROR = 'ERROR',
  PENDING = 'PENDING',
  RUNNING = 'RUNNING',
  UNKNOWN = 'UNKNOWN',
}

/** A page of the experiment entity */
export type ExperimentsPage = {
  __typename?: 'ExperimentsPage';
  /** The total `Experiment` matching the query criteria */
  count: Scalars['Int'];
  /** The `Experiment` data as an array */
  data: Array<Experiment>;
};

/** A file identified by its path in UNIX format */
export type File = {
  __typename?: 'File';
  /** The file id, in the format `/[...path]/[name]`. */
  id: Scalars['ID'];
  /** The file basename. */
  name: Scalars['String'];
  /** The file size in bytes. */
  size: Scalars['Float'];
  /** The file last modification date. */
  updatedAt?: Maybe<Scalars['DateTime']>;
};

/** A filesystem in the UNIX norm */
export type FileSystem = {
  __typename?: 'FileSystem';
  /** The list of all directories contained in the filesystem */
  directories: Array<Directory>;
  /** The list of all files contained in the filesystem */
  files: Array<File>;
  /** The filesystem ID */
  id: Scalars['ID'];
};

export type GitHubBranch = {
  __typename?: 'GitHubBranch';
  /** ID of the branch */
  id: Scalars['String'];
  /** Name of the branch */
  name: Scalars['String'];
};

export type GitHubFile = {
  __typename?: 'GitHubFile';
  /** Content of the file */
  content?: Maybe<Scalars['String']>;
  /** File name */
  name?: Maybe<Scalars['String']>;
  /** File type */
  type?: Maybe<Scalars['String']>;
};

export type GithubRepository = {
  __typename?: 'GithubRepository';
  /** ID of the repository */
  id: Scalars['String'];
  /** Name of the repository */
  name: Scalars['String'];
  /** URL of the repository */
  url: Scalars['String'];
};

/** The influx time series data */
export type InfluxDataItem = {
  __typename?: 'InfluxDataItem';
  /** The start of time series */
  _start: Scalars['String'];
  /** The end of time series */
  _stop: Scalars['String'];
  /** The current time associated to value */
  _time: Scalars['String'];
  /** The value associated to current time */
  _value: Scalars['Float'];
};

/** Represent one line (equivalent of one product) of an invoice */
export type InvoiceLine = {
  __typename?: 'InvoiceLine';
  /** Invoice line description */
  description?: Maybe<Scalars['String']>;
  /** Total of the line */
  lineTotal: Scalars['Float'];
};

/** JWT registered claims as described in the [RFC7519](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1) */
export type JwtPayload = {
  __typename?: 'JwtPayload';
  /** The JWT audience */
  aud: Scalars['String'];
  /** When the JWT expires. */
  exp: Scalars['Int'];
  /** When the JWT was issued. */
  iat: Scalars['Int'];
  /** The JWT issuer */
  iss: Scalars['String'];
  /** The JWT ID */
  jti: Scalars['String'];
  /** When the JWT is considered as valid. */
  nbf?: Maybe<Scalars['Int']>;
  /** The JWT subject */
  sub: Scalars['String'];
};

export type LoginResult = {
  __typename?: 'LoginResult';
  /** The JWT claims. They can also be obtained from the JWT payload. */
  payload: JwtPayload;
  /** The generated login JWT */
  token: Scalars['String'];
};

/** Directories where code and artifacts are located within the runtime container */
export type Mounts = {
  __typename?: 'Mounts';
  /** The directory where the artifacts is mounted within the runtime container */
  artifacts: Scalars['String'];
  /** The directory where the code is mounted within the runtime container */
  code: Scalars['String'];
};

/** Directories where code and artifacts are located within the runtime container */
export type MountsInput = {
  /** The directory where the artifacts is mounted within the runtime container */
  artifacts?: InputMaybe<Scalars['String']>;
  /** The directory where the code is mounted within the runtime container */
  code?: InputMaybe<Scalars['String']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  /** Activate new user account after clicking on the link in the activation email */
  activateAccount: Scalars['Boolean'];
  archiveExperiment: Scalars['Boolean'];
  archiveWorkload: Scalars['Boolean'];
  /** Cancel a running experiment */
  cancelExperiment: Scalars['Boolean'];
  /** Change the password of a given user */
  changePassword: Scalars['Boolean'];
  /** Create an access key associated to a workload */
  createAccessKey: Scalars['Boolean'];
  /** Creates a Stripe checkout session linked to the user */
  createCheckoutSession?: Maybe<Scalars['String']>;
  /** Creates a Stripe portal session linked to the user */
  createPortalSession?: Maybe<Scalars['String']>;
  /** Create a a registry linked to a external registry */
  createRegistry: Registry;
  /** Create a token for CLI authentication */
  createToken: TokenWithSecret;
  createWorkload: Workload;
  /** Delete an access key associated to a workload */
  deleteAccessKey: Scalars['Boolean'];
  /** Delete a registry */
  deleteRegistry: Scalars['Boolean'];
  /** Delete a token */
  deleteToken: Scalars['Boolean'];
  /** Disconnect github account to current user */
  disconnectGitHub: Scalars['Boolean'];
  /** Request the application to send an email with link to reset the user password. */
  forgotPassword: Scalars['Boolean'];
  /** Login in to the application with email/password credentials. */
  login: LoginResult;
  /** Create new user account by providing email/password credentials. */
  register: Scalars['Boolean'];
  /** Registers the user' GitHub auth token in the DB. */
  registerGitHubToken: Scalars['Boolean'];
  reportUsage: Scalars['Boolean'];
  /** Updates the password of a user */
  resetPassword: Scalars['Boolean'];
  /** Run an experiment with given parameters */
  runExperiment: Experiment;
  /** Create new user account by providing email/password credentials. */
  sendActivationMail: Scalars['Boolean'];
  startWorkload: Scalars['Boolean'];
  stopWorkload: Scalars['Boolean'];
  updateWorkload: Scalars['Boolean'];
};

export type MutationActivateAccountArgs = {
  token: Scalars['String'];
};

export type MutationArchiveExperimentArgs = {
  experimentId: Scalars['String'];
};

export type MutationArchiveWorkloadArgs = {
  workloadId: Scalars['String'];
};

export type MutationCancelExperimentArgs = {
  experimentId: Scalars['ID'];
};

export type MutationChangePasswordArgs = {
  currentPassword: Scalars['String'];
  newPassword: Scalars['String'];
};

export type MutationCreateAccessKeyArgs = {
  workloadId: Scalars['ID'];
};

export type MutationCreateCheckoutSessionArgs = {
  cancelUrl: Scalars['String'];
  successUrl: Scalars['String'];
};

export type MutationCreatePortalSessionArgs = {
  returnUrl: Scalars['String'];
};

export type MutationCreateRegistryArgs = {
  host: Scalars['String'];
  login: Scalars['String'];
  password: Scalars['String'];
};

export type MutationCreateTokenArgs = {
  name: Scalars['String'];
};

export type MutationCreateWorkloadArgs = {
  cpu: Scalars['Boolean'];
  docker_build_args?: InputMaybe<Scalars['String']>;
  dockerfile?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  noCode: Scalars['Boolean'];
  script_args: Scalars['String'];
  script_path: Scalars['String'];
  token?: InputMaybe<Scalars['String']>;
  url: Scalars['String'];
};

export type MutationDeleteAccessKeyArgs = {
  accessKey: Scalars['String'];
  workloadId: Scalars['String'];
};

export type MutationDeleteRegistryArgs = {
  registryId: Scalars['ID'];
};

export type MutationDeleteTokenArgs = {
  tokenId: Scalars['ID'];
};

export type MutationForgotPasswordArgs = {
  email: Scalars['String'];
};

export type MutationLoginArgs = {
  email: Scalars['String'];
  password: Scalars['String'];
};

export type MutationRegisterArgs = {
  email: Scalars['String'];
  password: Scalars['String'];
};

export type MutationRegisterGitHubTokenArgs = {
  code: Scalars['String'];
};

export type MutationResetPasswordArgs = {
  password: Scalars['String'];
  token: Scalars['String'];
};

export type MutationRunExperimentArgs = {
  code?: InputMaybe<Scalars['String']>;
  mounts?: InputMaybe<MountsInput>;
  name: Scalars['String'];
  repository?: InputMaybe<RepositoryInput>;
  resourcesRequest: ResourcesRequestInput;
  runtime: RuntimeInput;
  scripts: ScriptsInput;
};

export type MutationSendActivationMailArgs = {
  email: Scalars['String'];
};

export type MutationStartWorkloadArgs = {
  workloadId: Scalars['String'];
};

export type MutationStopWorkloadArgs = {
  workloadId: Scalars['String'];
};

export type MutationUpdateWorkloadArgs = {
  name: Scalars['String'];
  workloadId: Scalars['ID'];
};

export type Query = {
  __typename?: 'Query';
  billingUsage: Array<BillingUsageItem>;
  /** Return the URI containing the artifact to download */
  downloadExperimentArtifact: Scalars['String'];
  /** Returns the user's GitHub login name */
  getGitHubUser?: Maybe<Scalars['String']>;
  /** Returns the branches of a GitHub repo */
  getRepoBranches: Array<GitHubBranch>;
  /** Returns the content of a GitHub repo at a given path */
  getRepoDetails: Array<GitHubFile>;
  /** Return a Stripe Subscription object */
  getSubscription?: Maybe<StripeSubscription>;
  getUpcomingInvoice?: Maybe<DetailedInvoice>;
  /** Returns user's repo infos. */
  getUserRepos: Array<GithubRepository>;
  /** Indicates whether the user has one or several unpaid invoices. */
  hasUnpaidInvoices: Scalars['Boolean'];
  /** Return user entity related to the logged in user */
  me: User;
  /** Test ping query to check if teh GraphQL server is in good health */
  ping: Scalars['String'];
  /** Return the experiment with given ID */
  readExperiment: Experiment;
  /** Return the workload with given ID */
  readWorkload: Workload;
  workloadUsage: Array<InfluxDataItem>;
};

export type QueryBillingUsageArgs = {
  end: Scalars['DateTime'];
  period: Scalars['String'];
  start: Scalars['DateTime'];
};

export type QueryDownloadExperimentArtifactArgs = {
  artifactId: Scalars['ID'];
};

export type QueryGetRepoBranchesArgs = {
  owner: Scalars['String'];
  repository: Scalars['String'];
};

export type QueryGetRepoDetailsArgs = {
  branch: Scalars['String'];
  owner: Scalars['String'];
  path?: InputMaybe<Scalars['String']>;
  repository: Scalars['String'];
};

export type QueryPingArgs = {
  pong?: InputMaybe<Scalars['String']>;
};

export type QueryReadExperimentArgs = {
  experimentId: Scalars['ID'];
};

export type QueryReadWorkloadArgs = {
  workloadId: Scalars['ID'];
};

export type QueryWorkloadUsageArgs = {
  accessKey?: InputMaybe<Scalars['String']>;
  end: Scalars['DateTime'];
  period: Scalars['String'];
  start: Scalars['DateTime'];
  workloadId?: InputMaybe<Scalars['String']>;
};

/** A registry where to get a runtime container image */
export type Registry = {
  __typename?: 'Registry';
  /** The date when the registry has been created */
  createdAt: Scalars['DateTime'];
  /** The registry URI */
  host: Scalars['String'];
  /** The registry ID */
  id: Scalars['ID'];
  /** The login credential to use when fetching image from the registry */
  login: Scalars['String'];
};

/** The repository where to fetch the code */
export type Repository = {
  __typename?: 'Repository';
  /** The repository private SSH key. */
  privateKey?: Maybe<Scalars['String']>;
  /** The repository ref (can be a branch or tag). */
  ref: Scalars['String'];
  /** The repository uri, HTTPS or SSH format. */
  uri: Scalars['String'];
};

/** The repository where to fetch the code */
export type RepositoryInput = {
  /** The repository private SSH key. */
  privateKey?: InputMaybe<Scalars['String']>;
  /** The repository ref (can be a branch or tag). */
  ref: Scalars['String'];
  /** The repository uri, HTTPS or SSH format. */
  uri: Scalars['String'];
};

/** The allocated hardware resources */
export type ResourcesAllocation = {
  __typename?: 'ResourcesAllocation';
  /** The allocated cpus count in cores. */
  cpus: Scalars['Int'];
  /** The allocated gpus count. */
  gpus: Scalars['Int'];
  /** The allocated memory in MiB. */
  memory: Scalars['Int'];
};

/** The requested hardware resources */
export type ResourcesRequest = {
  __typename?: 'ResourcesRequest';
  /** The requested cpus count in cores; null means no constraint. */
  cpus?: Maybe<Scalars['Int']>;
  /** The requested gpus count; null means no constraint. */
  gpus?: Maybe<Scalars['Int']>;
  /** The requested memory in MiB; null means no constraint. */
  memory?: Maybe<Scalars['Int']>;
};

/** The requested hardware resources */
export type ResourcesRequestInput = {
  /** The requested cpus count in cores; null means no constraint. */
  cpus?: InputMaybe<Scalars['Int']>;
  /** The requested gpus count; null means no constraint. */
  gpus?: InputMaybe<Scalars['Int']>;
  /** The requested memory in MiB; null means no constraint. */
  memory?: InputMaybe<Scalars['Int']>;
};

/** The runtime container parameters */
export type Runtime = {
  __typename?: 'Runtime';
  /** The runtime container image URI */
  image: Scalars['String'];
  /** Whether the code should be executed as privileged user or not */
  privileged: Scalars['Boolean'];
};

export type RuntimeInput = {
  /** The runtime container image URI */
  image: Scalars['String'];
  /** Whether the code should be executed as privileged user or not */
  privileged: Scalars['Boolean'];
};

/** The scripts to run during the execution lifecycle */
export type Scripts = {
  __typename?: 'Scripts';
  /** The script to run once the start script has been successfully executed */
  end?: Maybe<Scalars['String']>;
  /** The script that will be run if an error occurs during the start script execution */
  error?: Maybe<Scalars['String']>;
  /** The script to run before executing the start script */
  prepare?: Maybe<Scalars['String']>;
  /** The main script to run during the lifecycle */
  start: Scalars['String'];
};

/** The scripts to run during the execution lifecycle */
export type ScriptsInput = {
  /** The script to run once the start script has been successfully executed */
  end?: InputMaybe<Scalars['String']>;
  /** The script that will be run if an error occurs during the start script execution */
  error?: InputMaybe<Scalars['String']>;
  /** The script to run before executing the start script */
  prepare?: InputMaybe<Scalars['String']>;
  /** The main script to run during the lifecycle */
  start: Scalars['String'];
};

export type StripeSubscription = {
  __typename?: 'StripeSubscription';
  currentPeriodEnd: Scalars['Float'];
  currentPeriodStart: Scalars['Float'];
  id: Scalars['String'];
  status: Scalars['String'];
};

export type Subscription = {
  __typename?: 'Subscription';
  streamExperimentLogs: TerminalRef;
  watchExperiment: Experiment;
  watchWorkload: BuildStatus;
};

export type SubscriptionStreamExperimentLogsArgs = {
  cols?: InputMaybe<Scalars['Int']>;
  experimentId: Scalars['ID'];
  rows?: InputMaybe<Scalars['Int']>;
};

export type SubscriptionWatchExperimentArgs = {
  experimentId: Scalars['ID'];
};

export type SubscriptionWatchWorkloadArgs = {
  workloadId: Scalars['ID'];
};

/** A terminal containing logs for an experiment */
export type TerminalRef = {
  __typename?: 'TerminalRef';
  /** The data output of the terminal */
  data: Scalars['String'];
  /** The terminal id corresponding to a SSH tunnel id */
  id: Scalars['ID'];
};

/** A token to authenticate while using the CLI */
export type Token = {
  __typename?: 'Token';
  /** The date when the token has been created */
  createdAt: Scalars['DateTime'];
  /** The token ID */
  id: Scalars['ID'];
  /** The token name */
  name: Scalars['String'];
};

export type TokenWithSecret = {
  __typename?: 'TokenWithSecret';
  /** The date when the token has been created */
  createdAt: Scalars['DateTime'];
  /** The token ID */
  id: Scalars['ID'];
  /** The token name */
  name: Scalars['String'];
  /** The token secret to return */
  secret: Scalars['String'];
};

/** A user account */
export type User = {
  __typename?: 'User';
  /** The date when the user has registered */
  createdAt: Scalars['DateTime'];
  /** The user email */
  email: Scalars['String'];
  /** A page of experiments created by given user */
  experiments: ExperimentsPage;
  /** The GitHub access token of the user */
  githubToken?: Maybe<Scalars['String']>;
  /** The user ID */
  id: Scalars['ID'];
  /** Registries belonging to given user */
  registries: Array<Registry>;
  /** The stripe ID of customer linked to the user */
  stripeId?: Maybe<Scalars['String']>;
  /** The stripe ID of SetupIntent storing the user payment method */
  subscriptionId?: Maybe<Scalars['String']>;
  /** CLI tokens created by given user */
  tokens: Array<Token>;
  /** The last date the user has been updated */
  updatedAt: Scalars['DateTime'];
  /** The date when the user has verified its email */
  verifiedAt?: Maybe<Scalars['DateTime']>;
  /** Workloads created by given user */
  workloads: Array<Workload>;
};

/** A user account */
export type UserExperimentsArgs = {
  page?: InputMaybe<Scalars['Int']>;
  perPage?: InputMaybe<Scalars['Int']>;
};

/** The user archipel workloads with metadata */
export type Workload = {
  __typename?: 'Workload';
  /** Archipel implementation of the workload */
  archipel: ArchipelWorkload;
  archived: Scalars['Boolean'];
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  name: Scalars['String'];
};

/** The Archipel memory footprint */
export type WorkloadMemoryFootprint = {
  __typename?: 'WorkloadMemoryFootprint';
  /** The workload batch vram footprint in megabytes */
  batch_vram_footprint: Scalars['Int'];
  /** The workload ram footprint in megabytes */
  model_ram_footprint: Scalars['Int'];
  /** The workload vram footprint in megabytes */
  model_vram_footprint: Scalars['Int'];
};

export enum WorkloadStatus {
  RUNNING = 'RUNNING',
  STARTING = 'STARTING',
  STOPPED = 'STOPPED',
}

export type InitializeUserMutationVariables = Exact<{
  email: Scalars['String'];
  password: Scalars['String'];
  skipLogin?: InputMaybe<Scalars['Boolean']>;
}>;

export type InitializeUserMutation = {
  __typename?: 'Mutation';
  register: boolean;
  login?: { __typename?: 'LoginResult'; token: string };
};

export type MeQueryVariables = Exact<{ [key: string]: never }>;

export type MeQuery = {
  __typename?: 'Query';
  me: { __typename?: 'User'; id: string; email: string; subscriptionId?: string | null };
};

export const InitializeUserDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'initializeUser' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'email' } },
          type: { kind: 'NonNullType', type: { kind: 'NamedType', name: { kind: 'Name', value: 'String' } } },
        },
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'password' } },
          type: { kind: 'NonNullType', type: { kind: 'NamedType', name: { kind: 'Name', value: 'String' } } },
        },
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'skipLogin' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Boolean' } },
          defaultValue: { kind: 'BooleanValue', value: false },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'register' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'email' },
                value: { kind: 'Variable', name: { kind: 'Name', value: 'email' } },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'password' },
                value: { kind: 'Variable', name: { kind: 'Name', value: 'password' } },
              },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'login' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'email' },
                value: { kind: 'Variable', name: { kind: 'Name', value: 'email' } },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'password' },
                value: { kind: 'Variable', name: { kind: 'Name', value: 'password' } },
              },
            ],
            directives: [
              {
                kind: 'Directive',
                name: { kind: 'Name', value: 'skip' },
                arguments: [
                  {
                    kind: 'Argument',
                    name: { kind: 'Name', value: 'if' },
                    value: { kind: 'Variable', name: { kind: 'Name', value: 'skipLogin' } },
                  },
                ],
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [{ kind: 'Field', name: { kind: 'Name', value: 'token' } }],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode;
export const MeDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'me' },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'me' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                { kind: 'Field', name: { kind: 'Name', value: 'email' } },
                { kind: 'Field', name: { kind: 'Name', value: 'subscriptionId' } },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode;

export type SdkFunctionWrapper = <T>(
  action: (requestHeaders?: Record<string, string>) => Promise<T>,
  operationName: string,
  operationType?: string,
) => Promise<T>;

const defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType) => action();

export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  return {
    initializeUser(
      variables: InitializeUserMutationVariables,
      requestHeaders?: Dom.RequestInit['headers'],
    ): Promise<InitializeUserMutation> {
      return withWrapper(
        (wrappedRequestHeaders) =>
          client.request<InitializeUserMutation>(InitializeUserDocument, variables, {
            ...requestHeaders,
            ...wrappedRequestHeaders,
          }),
        'initializeUser',
        'mutation',
      );
    },
    me(variables?: MeQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<MeQuery> {
      return withWrapper(
        (wrappedRequestHeaders) =>
          client.request<MeQuery>(MeDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }),
        'me',
        'query',
      );
    },
  };
}
export type Sdk = ReturnType<typeof getSdk>;
